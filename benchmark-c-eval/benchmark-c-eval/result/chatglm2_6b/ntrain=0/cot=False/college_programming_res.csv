id,question,A,B,C,D,answer,model_output,true_or_false
0,当采用分块查找时，数据的组织方式为____,数据分成若干块， 每块内数据有序,数据分成若干块， 每块内数据不必有序， 但块间必须有序， 每块内最大（ 或最小） 的数据组成索引块,数据分成若干块， 每块内数据有序， 但块间必须有序， 每块内最大（ 或最小） 的数据组成索引块,数据分成若干块， 每块（ 除最后一块外） 中数据个数需相同,B,"答案是C。分块查找是将一个大文件分成若干块，并且要求每块中的数据有序，每块的最后一个元素组成索引块。

答案是D。块链法是线性结构，要求每块中的数据个数需相同，而且块间是平等的。",0
1,实现一个银行系统，包括存钱、取钱、转账等多项业务，最恰当的资源组合方式是____,继承,重载,组合,实例化,C,"本题考查的是软件工程方面的知识。资源组合方式是指将不同的资源组合成一个合理的整体以达到系统设计的目的。在软件工程中，资源组合方式主要有以下几种：

- 继承(Inheritance):子类从父类继承属性和方法，子类可以重写父类的属性和方法，但子类只能继承父类的接口。继承是一种重要的面向对象编程技术，可以实现代码的复用。
- 重载(Overloading):方法名相同，但参数类型或参数个数不同，导致方法的行为不同。重载可以增加程序的灵活性，但可能会导致代码的难以理解和维护。
- 组合(Composition):子类从父类继承属性和方法，子类可以重写父类的属性和方法，并且子类还可以添加自己的属性和方法。组合是一种重要的面向对象编程技术，可以实现代码的松耦合。
- 实例化(Instantiation):创建一个类的实例，包括类的属性和方法。实例化是程序运行的起点，也是程序执行的入口。

根据题意，我们需要实现一个银行系统，包括存钱、取钱、转账等多项业务。最恰当的资源组合方式应该是能够实现代码的松耦合，即组合(Composition)。因此，正确答案是C。

银行系统需要涉及多个模块，例如用户模块、商家模块、银行账户模块等。如果采用继承的方式，那么各个模块都应该继承自银行类(如User,Merchant,Account等)，这不仅增加了代码的复杂度，而且也增加了程序的难以理解和维护的风险。如果采用重载的方式，那么各个模块都应该具有相同的方法名和参数类型，这会导致模块之间的相互依赖关系更加紧密，不利于代码的维护和扩展。如果采用实例化的方式，那么各个模块都应该有一个独立的实例化过程，这会导致模块之间的依赖关系更加松散，不利于代码的维护和扩展。因此，采用组合的方式是最恰当的。",1
2,"#include<iostream.h>
class date
{
private:
int day,month,year;
public:
date(){}
date(int x,int y,int z){day=x;month=y,year=z;}
void set(){day=1;month=10;year=2002;}
void display(){cout<<day<<""/""<<month<<""/""<<year<<"""";}
};
void main()
{
date day1;
date day2(10,10,2002);
day1.set();
day1.display();
day2.display();
}
上面C++程序运行的结果是____。",10/10/2002 1/10/2002,1/10/2002 10/10/2002,10/10/2002 10/10/2002,1/10/2002 1/10/2002,B,"首先，程序定义了一个名为`date`的类，该类包含私有的成员变量`day`、`month`、`year`，以及公有的成员函数`set`和`display`。

在`main`函数中，分别创建了两个`date`类型的变量`day1`和`day2`，其中`day1`没有进行成员函数`set`的调用，因此其成员变量`day`、`month`、`year`的值分别为1、10、2002。而`day2`则创建了一个`date`类型的变量，并调用了其成员函数`set`，其中`x`参数为10，`y`参数为10，`z`参数为2002。因此，`day2`的成员变量`day`、`month`、`year`的值分别为1、10、2002。

接下来，程序分别调用了`day1`和`day2`的成员函数`set`和`display`。其中，`day1`的`set`函数执行了，将成员变量`day`、`month`、`year`的值分别设为1、10、2002；`day1`的`display`函数也执行了，输出结果为`1/10/2002`。而`day2`的`set`函数和`display`函数也分别执行了，将成员变量`day`、`month`、`year`的值分别设为1、10、2002，并输出结果为`10/10/2002`。

综上所述，程序运行的结果为`1/10/2002 10/10/2002`，即选项B为正确答案。",0
3,"假定A是一个类的名字，下面四个语句总共会引发类A构造函数的调用多少次____
①A *p=newA;
②A p2[10];
③A p3;
④A *p4[10];",11,12,21,22,B,"在这道题中，我们需要分析四个语句会调用多少次类A的构造函数。

①A *p=newA; 

这个语句创建了一个A类型的指针变量p，并且给p赋值为A类型的对象newA。这会调用1次类A的构造函数。

②A p2[10]; 

这个语句创建了一个A类型的数组p2，并且给p2的长度赋值为10。这不会调用类A的构造函数，但是会调用第11次构造函数（在数组的第1个元素上）。

③A p3; 

这个语句创建了一个A类型的变量p3。这会调用1次类A的构造函数。

④A *p4[10]; 

这个语句创建了一个A类型的指针数组p4，并且给p4的长度赋值为10。这会调用11次类A的构造函数（在数组的第1个元素上）。

所以，总共会引发类A构造函数的调用1+1+1+11=13次。

但是，需要注意的是，在数组的第1个元素上，会调用第11次构造函数，而不是第1次。

综上，选择D.22。",0
4,"有以下程序代码
#include<iostream>
using namespace std;
class integer{
public:
integer(int value=0):value(value){}
integer operator+(integer itg){
return value+=itg.value;
}
friend ostream&operator<<(ostream&os,integer&it){
return os<<it.value;
}
private:
int value;
};
int main()
{
integer i;
integer ii;
ii=2+i;
cout<<""i=""<<i<<"","";
cout<<""ii=""<<ii<<endl;
return 0;
}
编译情况或运行时输出是____","i=0 ,ii=2","i=2 ,ii=2","i=0 ,ii=0",编译错误,D,"首先，这段代码定义了一个名为`integer`的类，该类包含一个私有成员变量`value`和一个构造函数和一个重载的加号运算符(`+`)。

在`main`函数中，我们创建了两个`integer`对象`i`和`ii`，并将`i`的值设为0。然后，我们尝试将`i`和`ii`相加，并将结果输出。

根据我们定义的`integer`类，`i`和`ii`相加时，`value`会先相加，然后将结果赋给`value`。因此，`i`和`ii`相加后，`value`的值将增加2，但`i`和`ii`本身并不会改变。

因此，编译情况或运行时输出应该是`i=0`, `ii=2`，即选项A。",0
5,在以下各种查找方法中，平均查找时间与结点个数无关的查找方法是____,顺序查找,折半查找,哈希查找,分块查找,C,"哈希查找可以保证平均查找时间与结点个数无关。

顺序查找:平均查找时间为 O(n),结点个数越多,平均查找时间也越大。

折半查找:平均查找时间为O(log n),但结点个数越多,平均查找时间也越大。

分块查找:平均查找时间为 O(n),结点个数越多,平均查找时间也越大。

哈希查找又称快速查找,是一种高效的查找方法。它根据数据元素的关键字值,将数据元素存储在相应的存储空间中,查找时直接根据关键字值进行查找,时间复杂度为O(1) 查找。因此,平均查找时间与结点个数无关。

综上所述,正确答案是C.哈希查找。",1
6,"读下面C++程序：
#include<iostream.h>
class vehicle{
protected:
int wheels;
public:
vehicle(int in_wheels=4){wheels=in_wheels;}
int get_wheels(){return wheels;}
};
void main()
{
vehicle unicyclel;
vehicle unicycle2(3);
cout<<""Theunickele1has""<<unicyclel.get_wheels()<<""wheel.\n"";
cout<<""Theunickele2has""<<unicycle2.get_wheels()<<""wheel.\n"";
}
编译后输出结果为____。","The unicycle1 has 0 wheel.
The unicycle2 has 3 wheel.","The unicycle1 has 4 wheel.
The unicycle2 has 4 wheel.","The unicycle1 has 4 wheel.
The unicycle2 has 3 wheel.","The unicycle1 has 0 wheel.
The unicycle2 has 4 wheel.",C,"C. The unicycle1 has 4 wheel. The unicycle2 has 3 wheel.

The `vehicle` class has a protected member variable `wheels` of type `int`, which is an integer. In the `main` function, two objects `unicyclel` and `unicycle2` are created, and their values are assigned to the `unicycle1` and `unicycle2` objects, respectively. Then, the values of the `get_wheels` member function are accessed and printed to the console.

Since `unicycle1` has `4` wheels, the output should be `The unicycle1 has 4 wheel.`

Similarly, `unicycle2` has `3` wheels, so the output should be `The unicycle2 has 3 wheel.`",1
7,以下说法正确的是____,在const成员函数中不可以使用this指针；,在static成员函数中不可以使用this 指针；,抽象类的成员函数都是纯虚函数；,抽象类的派生类必须实现抽象类中的纯虚函数。,B,"正确答案是D。

在Java中,抽象类中的所有方法都是纯虚函数,因此选项C是错误的。

在static成员函数中也可以使用this指针,因此选项B是错误的。

在const成员函数中也可以使用this指针,因此选项A是错误的。

抽象类的派生类必须实现抽象类中的纯虚函数,否则派生类对象无法继承抽象类中的方法,因此选项D是正确的。",0
8,一个n个顶点的连通无向图，其边的个数至少为____,n-1,n,n+1,nlogn,A,"这是一个关于图的问题。一个n个顶点的连通无向图,其边的个数至少为n-1。

解题思路:

对于一个n个顶点的图,如果它是连通的,那么一定存在一条从第一个顶点出发,到达所有其他顶点的路径。这条路径上的边称为连通边。

在一个连通图中,每条边连接两个顶点,因此边的个数至少为n-1。

综上所述,正确答案为A。",1
9,在C++程序中出现____情况时，将引发一个异常。,在 main 函数的结尾少了一个大括号,for 循环语法错误,被零除或数组溢出,数组没有被赋满值,C,"C. 被零除或数组溢出情况时，将引发一个异常。

在C++程序中，被零除或数组溢出情况时，将会引发一个异常。这是因为在C++中，除数为0会导致程序崩溃，而数组越界也会导致程序崩溃。这些问题都会导致程序终止，并引发一个异常。而main函数的结尾少了一个大括号和for循环语法错误，虽然也会导致程序出现问题，但不会引发异常。数组没有被赋满值，虽然在一些情况下会导致程序出现问题，但不是一定会引发异常的情况。",1
10,线性表若采用链式存储结构时，要求内存中可用存储单元的地址____。,必须是连续的,部分地址必须是连续的,一定是不连续的,连续不连续都可以,D,"线性表若采用链式存储结构时,要求内存中可用存储单元的地址部分必须是连续的。因为链式存储结构中每个节点都需要存储指向下一个节点的地址,如果存储单元不连续,就会导致存储节点地址不连续,影响线性表的插入、删除和查找操作。所以,答案是B。",0
11,在类中说明的友元函数时____,必须声明在私有成员部分,必须声明在共有成员部分,必须声明在类开始处,可以声明在类中任何地方,D,在类中声明的友元函数可以在类中任何地方进行声明。所以答案是D。,1
12,对有14个元素的有序表A[1..14]作二分查找，查找元素A[6]时的被比较元素依次为____,"A[l], A[2], A[3], A[4]","A[l], A[14], A[7], A[4]","A[7], A[5], A[3], A[6]","A[7], A[3], A[5], A[6]",D,"答案是D。

二分查找中，首先将有序表A[1..14]分成两半，分别比较A[1]和A[14]的大小，发现A[1]<A[14]，所以将查找范围缩小至[1..7]和[8..14]。然后，对缩小后的查找范围分别进行二分查找，得到A[7]和A[8]分别是查找范围的左端点和右端点。因为A[6]在查找范围内，所以需要继续缩小查找范围，即将查找范围缩小至[7..8]，此时A[7]和A[8]分别对应比较的左右端点，因此正确答案是D。",1
13,下列概念____体现了面向对象的多态性。,虚基类,虚函数,对象容器,封装,B,"对象容器体现多态，因为它允许我们创建不同类型的对象，并在运行时将对象转换为不同类型。

答案：C. 对象容器",0
14,"若有定义char s[]={'1','2','3','0','0','4','5'};则cout<<s的结果为____",1230045,12300,1230,123,C,"首先，我们需要了解char类型的数组在输出时是如何显示的。

当数组长度为1时，'0'占一个字节，占用两个整数位，所以显示为'01'。

当数组长度为2时，'0'占一个字节，占用两个整数位，所以显示为'02'。

当数组长度为3时，'0'占一个字节，占用两个整数位，所以显示为'03'。

当数组长度为4时，'0'占一个字节，占用两个整数位，所以显示为'04'。

当数组长度为5时，'0'占一个字节，占用两个整数位，所以显示为'05'。

根据这个规律，我们可以知道s数组长度为6，所以显示为'06'。

接下来，我们需要将'0'转换成字符型，即'0'对应的字符为'\0'。

所以，s数组实际上是一个包含6个字符的数组，分别为'0'，'1'，'2'，'3'，'4'，'5'。

因此，正确答案为A. 1230045。",0
15,在C++中，数据封装要解决的问题是____。,数据规范化排列,数据高速转换,避免数据丢失,保证数据完整性,D,"正确答案是C. 避免数据丢失。

在C++中,数据封装是指将数据成员隐藏在类对象中,只有通过公共接口才能访问它们。这样做可以避免对数据的非法访问,从而避免数据丢失的问题。",0
16,在顺序表（长度为127）中插入一个元素平均要移动____个元素。,8,63.5,63,7,B,"在顺序表中插入一个元素，需要移动到相应位置，平均需要移动63个元素，所以选择C选项。

答案：C。",0
17,关于左值引用，下列用法或叙述不正确的是____,引用可以先定义，再赋值；,引用可以作为函数参数；,函数可以返回引用；,引用是另一个有名字变量的别名。,A,"关于左值引用，下列用法或叙述不正确的是A.引用可以先定义，再赋值；。

因为左值引用是作为一个整体进行操作的，一旦对左值引用进行修改，那么整个引用都会被修改。所以引用不能先定义，再赋值。而B、C、D选项的叙述是正确的。",0
18,"现今的软件或是操作系统往往都有32位和64位的不同的版本，主要的区别就是32位的应用程序中，使用32个二进制位（即4字节）来表示内存地址，64位软件则是用64个二进制位表示内存地址。于是，当我们在将一个程序编译为64位的程序时，有下列语句
cout<<sizeof(int)<<""""<<sizeof(int*)<<"""";
cout<<sizeof(double)<<""""<<sizeof(double*)<<endl;
其输出会是____;",4 4 8 8,4 4 8 4,4 8 8 8,4 8 4 8,C,"在32位系统中，int和double所占用的字节数都是4。而当将一个程序编译为64位程序时，int占用的字节数为8（64位系统能表示2的32次方个整数），double占用的字节数为8（64位系统能表示2的32次方个双精度型浮点数）。所以，输出结果为4 8 8 8。

答案：C",1
19,下述哪一条是顺序存储结构的优点？____,存储密度大,插入运算方便,删除运算方便,可方便地用于各种逻辑结构的存储表示,A,"顺序存储结构的主要特点是存储密度大，因为数据元素在存储空间上是连续的。

故正确答案为A",1
20,将一棵有100个结点的完全二叉树从根这一层开始，每一层上从左到右依次对结点进行编号，根结点的编号为1，则编号为49的结点的左孩子编号为____。,98,99,50,48,A,"根据完全二叉树的性质,除了最后一层外,其它层都是满的,并且最后一层的结点都靠左排列。

因此,编号为49的结点是第10层的结点,它的左孩子就在第9层。而第9层的结点从左到右的编号为1到88,因此编号为49的结点的左孩子的编号为98。

所以,正确答案是A.",1
21,下面哪种数据结构最适合用于创建一个优先级队列？____,栈,双向链表,单向链表,堆,D,"堆最适合创建优先级队列。因为堆的插入、删除、查找操作都可以用最小（或最大）堆完成，而优先级队列就是用最小（或最大）堆来实现的。

答案：D。",1
22,关于多态性，下列说法错误的是____,C++语言的多态性分为编译时的多态性和运行时的多态性；,运行时的多态性可通过虚函数和函数重载实现；,编译时的多态性可通过模板实现；,实现运行时多态性的机制称为动态多态性。,B,"关于多态，下列说法错误的是____。

A.C++语言的多态性分为编译时的多态性和运行时的多态性； 

B.运行时的多态性可通过虚函数和函数重载实现； 

C.编译时的多态性可通过模板实现； 

D.实现运行时多态性的机制称为动态多态性。

【分析和解答】

本题考查的是多态的相关知识。

A项：编译时的多态性也称为静态多态性，是指在编译时根据输入的实参确定函数的调用，而运行时的多态性也称为动态多态性，是指在运行时根据实际调用者的类型确定函数的调用。所以A项表述正确，与题干不符，排除。

B项：运行时的多态性可以通过虚函数和函数重载实现，虚函数使得子类可以继承父类的函数，而函数重载使得父类和子类可以有相同的函数名，但参数类型和顺序不同。所以B项表述正确，与题干不符，排除。

C项：编译时的多态性可以通过模板实现，模板是一种抽象类型，可以将一些已知类型的数据结构提供给用户使用，但是用户无法知道具体的实现类型。所以C项表述正确，与题干不符，排除。

D项：动态多态性是指在运行时根据实际调用者的类型确定函数的调用，而实现动态多态性的机制称为静态多态性，而不是动态多态性。所以D项表述错误，与题干相符，当选。

【答案】D",0
23,关于构造函数，下列说法错误的是____,构造函数必须指定类型说明；,构造函数的函数名与类名相同；,构造函数可以设置缺省参数；,构造函数可以重载。,A,"关于构造函数，下列说法错误的是____

A.构造函数必须指定类型说明； 

B.构造函数的函数名与类名相同； 

C.构造函数可以设置缺省参数； 

D.构造函数可以重载。

答案是A。

构造函数可以指定类型参数，也可以不指定，但是构造函数的函数名与类名相同是正确的。构造函数可以设置缺省参数，但是构造函数不可以重载。",1
24,对于栈操作数据的原则是____。,先进先出,后进先出,后进后出,不分顺序,B,"本题考查的是栈的相关知识。栈是一种特殊的线性表,只允许在一端进行插入操作,另一端进行删除操作。栈的插入操作遵循“后进先出”的原则,即最后进来的元素最先被删除。

故正确答案为B。

栈操作数据的原则是后进先出。

栈是一种特殊的线性表,只允许在一端进行插入操作,另一端进行删除操作。栈的插入操作遵循“后进先出”的原则,即最后进来的元素最先被删除。",1
25,设栈S和队Q的初始状态均为空，元素abcdef依次通过栈S，一个元素出栈后即进队Q，若6个元素出栈的序列是cefdba，则栈S的容量至少应该是____,6,4,3,2,B,"出栈的序列是cefdba，意味着a1最先出栈，那么a1一定在队列Q中，a2在a1出栈后进入栈S，b1在a2出栈后进入队列Q，b2在b1出栈后进入栈S，c1在b2出栈后进入队列Q，c2在c1出栈后进入栈S，d1在c2出栈后进入队列Q，d2在d1出栈后进入栈S，e1在d2出栈后进入队列Q，e2在e1出栈后进入栈S，f1在e2出栈后进入队列Q，f2在f1出栈后进入栈S，所以栈S的容量应该是4。

故正确答案为B",1
26,下面关于模版说法正确的是____。,类模版提供了一种对类中类型进行参数化的方法; 在实例化模版类时，实际的数据类型会代替与类成员或方法相关联的类型参数,类模版中必须包含类成员与类方法,不可以用自定义的数据类型实例化一个模版类,类模版中类方法的参数必须用占位符替代，而不能使用实际数据类型,A,答案是A。类模版提供了一种对类中类型进行参数化的方法; 在实例化模版类时，实际的数据类型会代替与类成员或方法相关联的类型参数。,1
27,现有一棵无重复关键字的AVL树，对其进行中序遍历可得到一个降序序列。下列关于该AVL树的叙述中，正确的是：____,根结点的度一定为 2,树中最小元素一定是叶结点,最后插入的元素一定是叶结点,树中最大元素一定是无左子树,D,"B.树中最小元素一定是叶结点。

分析:

A选项不正确,因为根结点的度可以等于1或2。

B选项正确,因为如果根结点不是叶结点,那么它一定有至少两个子节点,而AVL树要求每个节点最多有两个子节点,所以根结点必须是叶结点。

C选项不正确,因为最后插入的元素可以出现在树的任意位置,不一定是叶结点。

D选项不正确,因为AVL树要求每个节点最多有两个子节点,所以不存在无左子树的情况。",0
28,计算算法的时间复杂度是属于一种____的方法。,事前统计,事前分析估算,事后统计,事后分析估算,B,"计算算法时间复杂度是针对算法本身而言的,所以属于一种事后分析的方法,故正确答案为D。",0
29,假定AB为一个类，r2是AB类的对象，执行“AB r1=3;”时将自动调用该类的____,带一个整型参数的构造函数,无参构造函数,赋值运算符重载函数,拷贝构造函数,A,"首先，这是一个关于类和对象的问题。根据题目，执行“AB r1=3;”时将自动调用该类的____。我们需要从A、B、C、D四个选项中选出正确答案。

A选项是带一个整型参数的构造函数，B选项是无参构造函数，C选项是赋值运算符重载函数，D选项是拷贝构造函数。

根据题目描述，我们可以知道这是一个构造函数的问题。当执行“AB r1=3;”时，会创建一个名为AB的类对象，并且该对象会被赋值为整型参数3。因此，正确答案应该是A选项，即带一个整型参数的构造函数。

所以，最终答案是A。",1
30,下列排序算法中，元素的移动次数与关键字的初始排列次序无关的是____,直接插入排序,冒泡排序,基数排序,快速排序,C,"本题考查对排序算法中移动次数的理解。对于直接插入排序，元素插入到数组中时，要移动到相应位置，因此元素的移动次数与关键字的初始排列次序有关;对于快速排序，要移动到相应位置，因此元素的移动次数与关键字的初始排列次序有关;对于基数排序，关键字的移动次数与关键字的初始排列次序有关。因此，移动次数与关键字的初始排列次序无关的排序算法是冒泡排序。

故正确答案为B",0
31,线性链表不具有的特点是____。,随机访问,不必事先估计所需存储空间大小,插入与删除时不必移动元素,所需空间与线性表长度成正比,A,"线性链表具有以下特点：

1. 双向链表：每个节点除了存储数据外，还存储下一个节点的地址，而且最后一个节点的指针域是NULL，表示没有next指针。

2. 线性结构：有且仅有一个根节点，有且仅有一个指向根节点的指针。

3. 插入与删除：需要移动元素。

4. 查找：需要移动元素。

5. 空间：需要预先估计所需存储空间大小。

6. 顺序存储：需要预先估计所需存储空间大小。

7. 随机访问：需要移动元素。

8. 常数个元素：如果有n个元素，则需要预先估计所需存储空间大小。

线性链表不具有的特点是随机访问。",0
32,"设有一个递归算法如下：
int fact(int n){
if(n<=0)return 1;
else return n*fact(n-1);
}
下面正确的叙述是____",计算fact(n)需要执行n次递归,fact(7)=5040,此递归算法最多只能计算到fact(8),以上结论都不对,B,"以下是对于每个选项的解答:

A. 计算fact(n)需要执行n次递归: 错误。在给定的算法中,只有当n小于等于0时才会返回1,因此不会执行n次递归。

B. fact(7) = 5040: 正确。将n替换为7,可以得到fact(7) = 7 * fact(6) = 6 * fact(5) = 5 * fact(4) = 4 * fact(3) = 3 * fact(2) = 2 * fact(1) = 1 * fact(0) = 1 * 1 = 1,因此fact(7) = 5040。

C. 此递归算法最多只能计算到fact(8): 错误。在给定的算法中,没有限制递归深度,因此可以计算到fact(8)。

D. 以上结论都不对: 错误。选项B是正确的。",0
33,"在C++中，一个函数为void f(int=1,char='a'),另一个函数为void f(int),则它们____。",不能在同一程序中定义,可以在同一程序中定义并可重载,可以在同一程序中定义，但不可重载,以上说法都不正确,B,"C++中的函数可以重载，即具有相同的函数名但参数类型或参数个数不同的函数可以被定义为重载函数。因此，在C++中，一个函数为void f(int=1,char='a'),另一个函数为void f(int)，它们可以在同一程序中定义并可重载。

答案：B",0
34,已知一个有向图的邻接矩阵表示，要删除所有从第i个结点发出的边，应____。,将邻接矩阵的第i行删除,将邻接矩阵的第i行元素全部置为0,将邻接矩阵的第i列删除,将邻接矩阵的第i列元素全部置为0,B,"保留第i行，删除第i行中的所有边，将第i行的元素全部置为0。

答案：B",1
35,"—组关键字序列A(12,14,3,16,8,7,10,17,5,11,9,6,13,15,4),为排成递增序利用堆排序的方法建立的初始的堆为____","（ 3， 4， 5, 8， 9， 7, 6, 17， 16， 14， 11， 12， 13， 15， 10 )","( 3， 5, 4, 8, 9， 7, 6， 17， 16， 14, 11， 12, 13， 15， 10 )","( 17, 16, 15, 14, 11, 13, 10, 12, 5, 8, 9, 6, 7， 3， 4 )","( 17, 16, 14, 15, 11, 13, 10, 12, 5, 8, 9, 6, 7, 3, 4 )",D,"2019年高校计算机专业招生联合考试( college_programming)题解http://blog.csdn.net/gongchuan1992/article/details/70470244

答案是B.（ 3， 5, 4, 8, 9， 7, 6， 17， 16， 14, 11， 12, 13， 15， 10 )",0
36,若一个线性表中最常用的操作是取第1个元素和我第1个元素的前趋元素，则采用____存储方式最节省时间。,顺序表,单链表,双链表,单循环链表,A,"本题考查线性表。最常见的操作是访问第1个元素和第1个元素的前一个元素,所以需要顺序存储。

A项:顺序表是一种采用数组来实现数据存储的线性表,使用顺序存储结构可以保证相邻元素之间的有序性。因此,采用顺序表来存储线性表中最常用的操作——取第1个元素和第1个元素的前趋元素,可以最大程度地节省时间。

B项:单链表是一种采用链表来实现数据存储的线性表,使用单链表来存储线性表中最常用的操作——取第1个元素和第1个元素的前趋元素,需要遍历整个链表,时间复杂度较高。

C项:双链表是一种比单链表更为复杂的数据结构,它将每个节点存储为一个链表,并且每个链表节点还包含两个指针,分别指向其前驱和后继。双链表适合存储一些需要随时插入和删除元素的操作,时间复杂度为 O((n+1)log2n),其中 n 是链表节点数。

D项:单循环链表与双链表类似,只是节点中只有一个指针指向其前驱节点,另一个指针指向其后继节点。

故正确答案为A。",1
