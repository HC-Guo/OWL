id,question,A,B,C,D,answer,model_output,true_or_false
0,当采用分块查找时，数据的组织方式为____,数据分成若干块， 每块内数据有序,数据分成若干块， 每块内数据不必有序， 但块间必须有序， 每块内最大（ 或最小） 的数据组成索引块,数据分成若干块， 每块内数据有序， 但块间必须有序， 每块内最大（ 或最小） 的数据组成索引块,数据分成若干块， 每块（ 除最后一块外） 中数据个数需相同,B,"
让我们一步一步思考,
1. 首先，我们需要了解分块查找的概念。分块查找是将一个大块的连续数据分成若干块，对每一块进行查找，将查找结果存回原来的位置，这样可以减少查找次数。
2. 接着，我们来分析选项。A选项表示每块内数据有序，这是错误的，因为分块查找是将数据分成若干块，每块内数据不必有序。B选项表示块间必须有序，每块内最大（或最小）的数据组成索引块，这也是错误的，因为分块查找是每一块内最大（或最小）的数据组成索引块。D选项表示数据分成若干块，每块（除最后一块外）中数据个数需相同，这也是错误的，因为分块查找是将数据分成若干块，每一块中数据个数可以不同。
3. 综上所述，正确的选项是C，即数据分成若干块，每块内数据有序，但块间必须有序，每块内最大（或最小）的数据组成索引块。",0
1,实现一个银行系统，包括存钱、取钱、转账等多项业务，最恰当的资源组合方式是____,继承,重载,组合,实例化,C,"
让我们一步一步思考,
1. 首先，我们需要了解继承、重载和组合的概念。
2. 接着，我们需要分析各项业务之间的关系，即存钱、取钱、转账等业务是否相互独立。显然，它们是相互独立的，因此我们需要使用组合的方式来实现多项业务。
3. 最后，我们需要将组合的方式具体化，即编写具体的实现函数。
所以答案是：C",1
2,"#include<iostream.h>
class date
{
private:
int day,month,year;
public:
date(){}
date(int x,int y,int z){day=x;month=y,year=z;}
void set(){day=1;month=10;year=2002;}
void display(){cout<<day<<""/""<<month<<""/""<<year<<"""";}
};
void main()
{
date day1;
date day2(10,10,2002);
day1.set();
day1.display();
day2.display();
}
上面C++程序运行的结果是____。",10/10/2002 1/10/2002,1/10/2002 10/10/2002,10/10/2002 10/10/2002,1/10/2002 1/10/2002,B,"
让我们一步一步思考,
1. 首先，我们需要了解这个程序中定义的date类。
2. 接着，我们来分析main函数的执行过程。
3. 调用day1.set()函数时，设置day为1，month为10，year为2002。
4. 调用day1.display()函数时，输出10/10/2002。
5. 调用day2.set()函数时，设置day为1，month为10，year为2002。
6. 调用day2.display()函数时，输出1/10/2002。
所以答案是：A",0
3,"假定A是一个类的名字，下面四个语句总共会引发类A构造函数的调用多少次____
①A *p=newA;
②A p2[10];
③A p3;
④A *p4[10];",11,12,21,22,B,"
让我们一步一步思考,
1. ①会调用1次构造函数。
2. ②会调用11次构造函数（创建10个A对象）。
3. ③会调用1次构造函数。
4. ④会调用11次构造函数（创建10个A对象）。
所以总共会引发类A构造函数的调用12次。
所以答案是：B",1
4,"有以下程序代码
#include<iostream>
using namespace std;
class integer{
public:
integer(int value=0):value(value){}
integer operator+(integer itg){
return value+=itg.value;
}
friend ostream&operator<<(ostream&os,integer&it){
return os<<it.value;
}
private:
int value;
};
int main()
{
integer i;
integer ii;
ii=2+i;
cout<<""i=""<<i<<"","";
cout<<""ii=""<<ii<<endl;
return 0;
}
编译情况或运行时输出是____","i=0 ,ii=2","i=2 ,ii=2","i=0 ,ii=0",编译错误,D,"
让我们一步一步思考,
1. 首先，我们需要了解这段程序的逻辑。该程序定义了一个名为integer的类，该类包含一个私有成员变量value和一个构造函数和一个重载加号运算符的成员函数operator+。
2. 接着，我们分析main函数的执行过程。首先，我们创建了一个integer类型的变量i和一个integer类型的变量ii，并给ii赋值为2+i。
3. 然后，我们输出i和ii的值。由于i未被定义，所以i的值无法确定。但是，由于ii的值为2+i，所以i的值必须为0。
4. 最后，我们输出i和ii的值。i的值为0，ii的值为2。
所以答案是：A",0
5,在以下各种查找方法中，平均查找时间与结点个数无关的查找方法是____,顺序查找,折半查找,哈希查找,分块查找,C,"
让我们一步一步思考,
1. 顺序查找：每次查找都需要遍历整个数组，平均查找时间为O(n)
2. 折半查找：每次查找都需要将查找区间缩小一半，平均查找时间为O(log n)
3. 哈希查找：查找某个元素时，只需要计算哈希值，不需要遍历整个数组，平均查找时间为O(1)
4. 分块查找：需要将数组分成若干个块，每个块中查找元素，平均查找时间为O(n/块)
所以答案是：C",1
6,"读下面C++程序：
#include<iostream.h>
class vehicle{
protected:
int wheels;
public:
vehicle(int in_wheels=4){wheels=in_wheels;}
int get_wheels(){return wheels;}
};
void main()
{
vehicle unicyclel;
vehicle unicycle2(3);
cout<<""Theunickele1has""<<unicyclel.get_wheels()<<""wheel.\n"";
cout<<""Theunickele2has""<<unicycle2.get_wheels()<<""wheel.\n"";
}
编译后输出结果为____。","The unicycle1 has 0 wheel.
The unicycle2 has 3 wheel.","The unicycle1 has 4 wheel.
The unicycle2 has 4 wheel.","The unicycle1 has 4 wheel.
The unicycle2 has 3 wheel.","The unicycle1 has 0 wheel.
The unicycle2 has 4 wheel.",C,"
让我们一步一步思考,
1. 首先，我们需要了解这个程序中定义的车辆类（vehicle）的成员函数和成员变量。
2. 然后，我们来分析程序的执行过程。
3. 在main函数中，我们创建了两个车辆对象：unicyclel和unicycle2。
4. 对于unicyclel，调用get_wheels()函数获取其轮子数，由于成员函数中未定义get_wheels()函数，所以会默认调用成员函数的函数体。
5. 在get_wheels()函数中，返回了unicyclel的轮子数，即4。
6. 对于unicycle2，同样调用get_wheels()函数获取其轮子数，由于成员函数中未定义get_wheels()函数，所以会默认调用成员函数的函数体。
7. 在get_wheels()函数中，返回了unicycle2的轮子数，即4。
8. 最后，我们输出unicyclel和unicycle2的轮子数。
9. 根据输出结果，我们可以得出答案为D，即The unicycle1 has 0 wheel.
The unicycle2 has 4 wheel.",0
7,以下说法正确的是____,在const成员函数中不可以使用this指针；,在static成员函数中不可以使用this 指针；,抽象类的成员函数都是纯虚函数；,抽象类的派生类必须实现抽象类中的纯虚函数。,B,"
让我们一步一步思考,
1. A选项说在const成员函数中不可以使用this指针，这是错误的，因为const成员函数可以访问this指针。
2. B选项说在static成员函数中不可以使用this指针，这也是错误的，因为static成员函数可以访问this指针。
3. C选项说抽象类的成员函数都是纯虚函数，这是错误的，因为抽象类的成员函数可以是纯虚函数，也可以是普通函数。
4. D选项说抽象类的派生类必须实现抽象类中的纯虚函数，这是正确的，因为派生类必须保持抽象类中的纯虚函数特性。
所以答案是：D",0
8,一个n个顶点的连通无向图，其边的个数至少为____,n-1,n,n+1,nlogn,A,"
让我们一步一步思考,
1. 一个n个顶点的连通无向图，其边的个数至少为n-1，因为每个顶点都会连接n-1条边。
2. 所以答案是：A",1
9,在C++程序中出现____情况时，将引发一个异常。,在 main 函数的结尾少了一个大括号,for 循环语法错误,被零除或数组溢出,数组没有被赋满值,C,"
让我们一步一步思考,
1. 在C++程序中，如果一个for循环语法错误，则会引发一个异常。
2. 因此，答案是：B",0
10,线性表若采用链式存储结构时，要求内存中可用存储单元的地址____。,必须是连续的,部分地址必须是连续的,一定是不连续的,连续不连续都可以,D,"
让我们一步一步思考,
1. 当链式存储结构中，每个节点都需要存储指向下一个节点的指针，因此内存中需要连续存储这些指针。
2. 因此，内存中可用存储单元的地址必须是连续的。
所以答案是：A",0
11,在类中说明的友元函数时____,必须声明在私有成员部分,必须声明在共有成员部分,必须声明在类开始处,可以声明在类中任何地方,D,"
让我们一步一步思考,
1. 友元函数是在类中声明的，所以选项A和B都不正确。
2. 友元函数可以声明在类开始处，也可以声明在类中任何地方，所以选项C不正确。
3. 因此，答案是：D",1
12,对有14个元素的有序表A[1..14]作二分查找，查找元素A[6]时的被比较元素依次为____,"A[l], A[2], A[3], A[4]","A[l], A[14], A[7], A[4]","A[7], A[5], A[3], A[6]","A[7], A[3], A[5], A[6]",D,"
让我们一步一步思考,
1. 首先，我们需要了解二分查找的基本思想：每次将查找区间缩小一半，直到找到或者确定不存在为止。
2. 然后，我们根据题目给出的有序表A[1..14]和要查找的元素A[6]来进行二分查找。
3. 由于要查找的元素A[6]在有序表的中间位置，因此第一次查找时需要比较A[1]和A[2]两个元素。
4. 如果A[1]>A[2]，则说明A[6]在A[1]和A[2]之间，将查找区间缩小为[1,2]；如果A[1]<A[2]，则说明A[6]在A[1]和A[2]之间，将查找区间缩小为[2,3]。
5. 重复以上步骤，直到找到A[6]或者确定A[6]不存在。
6. 根据题目要求，我们需要找到A[6]时被比较的元素，即A[1], A[2], A[3], A[4]四个元素。
所以答案是：A",0
13,下列概念____体现了面向对象的多态性。,虚基类,虚函数,对象容器,封装,B,"
让我们一步一步思考,
1. 虚函数是C++中实现多态的重要手段，通过虚函数，可以在子类中重写父类的方法，从而实现多态。
2. 虚基类是C++中实现多态的一种手段，通过将一个基类声明为虚基类，然后将派生类继承该基类，从而实现多态。
3. 对象容器是C++中实现多态的一种手段，通过将一个容器声明为对象容器，然后将容器中的元素声明为对象的成员，从而实现多态。
4. 封装是C++中实现多态的一种手段，通过将一个类中的方法或成员隐藏起来，从而实现多态。
所以答案是：B",1
14,"若有定义char s[]={'1','2','3','0','0','4','5'};则cout<<s的结果为____",1230045,12300,1230,123,C,"
让我们一步一步思考,
1. 我们需要了解一个公式：%cout<<s[i]%
2. 然后，我们分析给定的定义char s[]={'1','2','3','0','0','4','5'};
3. 我们可以发现，%cout<<s[i]%的结果为：%cout<<s[i]%
4. 因此，%cout<<s的结果为：%cout<<s[0]%
5. 所以，答案是：A",0
15,在C++中，数据封装要解决的问题是____。,数据规范化排列,数据高速转换,避免数据丢失,保证数据完整性,D,"
让我们一步一步思考,
1. 数据封装是指将数据隐藏在类或结构中，不暴露给外部。
2. 数据封装可以解决数据丢失的问题，因为通过封装，数据可以被隐藏起来，不会丢失。
所以答案是：C",0
16,在顺序表（长度为127）中插入一个元素平均要移动____个元素。,8,63.5,63,7,B,"
让我们一步一步思考,
1. 首先，我们需要知道顺序表中插入一个元素需要移动多少个元素。由于顺序表的长度为127，所以插入一个元素需要移动到数组的最后一个位置，即需要移动127个元素。
2. 然后，我们需要计算平均移动元素的数量。平均移动元素的数量等于总移动元素的数量除以插入元素的位置。
3. 总移动元素的数量等于插入元素之前的元素个数加上插入元素之后的元素个数，即127+1=128。
4. 平均移动元素的数量等于128/127=1.006，即0.006052。
5. 将平均移动元素的数量转换为整数，即0.006052≈0。
6. 因此，平均移动元素的数量为0，即不需要移动元素。
所以答案是：D",0
17,关于左值引用，下列用法或叙述不正确的是____,引用可以先定义，再赋值；,引用可以作为函数参数；,函数可以返回引用；,引用是另一个有名字变量的别名。,A,"
让我们一步一步思考,
1. A选项不正确，引用必须在使用前定义。
2. B选项正确，引用可以作为函数参数。
3. C选项正确，函数可以返回引用。
4. D选项正确，引用是另一个有名字变量的别名。
所以答案是：A",1
18,"现今的软件或是操作系统往往都有32位和64位的不同的版本，主要的区别就是32位的应用程序中，使用32个二进制位（即4字节）来表示内存地址，64位软件则是用64个二进制位表示内存地址。于是，当我们在将一个程序编译为64位的程序时，有下列语句
cout<<sizeof(int)<<""""<<sizeof(int*)<<"""";
cout<<sizeof(double)<<""""<<sizeof(double*)<<endl;
其输出会是____;",4 4 8 8,4 4 8 4,4 8 8 8,4 8 4 8,C,"
让我们一步一步思考,
1. 32位程序中，int占4个字节，double占8个字节。
2. 64位程序中，int占4个字节，double占8个字节。
3. 因此，输出为4 4 8 8。
所以答案是：A",0
19,下述哪一条是顺序存储结构的优点？____,存储密度大,插入运算方便,删除运算方便,可方便地用于各种逻辑结构的存储表示,A,"
让我们一步一步思考,
1. 顺序存储结构是一种线性结构，它的数据元素在连续的物理空间中，因此存储密度大。
2. 插入、删除运算都较为复杂，需要移动元素，因此不是优点。
3. 顺序存储结构适用于线性结构的存储，不适用于其他逻辑结构的存储。
所以答案是：A",1
20,将一棵有100个结点的完全二叉树从根这一层开始，每一层上从左到右依次对结点进行编号，根结点的编号为1，则编号为49的结点的左孩子编号为____。,98,99,50,48,A,"
让我们一步一步思考,
1. 这棵完全二叉树有100个结点，那么有50个满结点。
2. 根结点的编号为1，那么编号为49的结点一定是满结点。
3. 满结点左边的结点一定是空结点，所以编号为49的结点的左孩子编号为99。
所以答案是：B",0
21,下面哪种数据结构最适合用于创建一个优先级队列？____,栈,双向链表,单向链表,堆,D,"
让我们一步一步思考,
1. 优先级队列需要维护两个端队列，一个用于插入元素，一个用于删除元素。
2. 栈可以满足这个要求，因为它具有后进先出（LIFO）的特性，即新元素会被压入栈的尾部，而元素会被从栈的头部取出。
3. 双向链表和单向链表虽然也可以存储元素，但是它们更适合存储结构体或类，而不是用于实现优先级队列。
4. 堆不适合用于实现优先级队列，因为它主要用于存储具有最高或最低优先级的数据。
所以答案是：A",0
22,关于多态性，下列说法错误的是____,C++语言的多态性分为编译时的多态性和运行时的多态性；,运行时的多态性可通过虚函数和函数重载实现；,编译时的多态性可通过模板实现；,实现运行时多态性的机制称为动态多态性。,B,"
让我们一步一步思考,
1. 多态性分为编译时的多态性和运行时的多态性。编译时的多态性是指在编译时根据参数的类型和数量来确定调用哪个函数，而运行时的多态性是指在运行时根据对象的实际类型来确定调用哪个函数。
2. 选项A正确，选项B正确，选项C正确。
3. 选项D错误，实现运行时多态性的机制称为动态多态性，而不是静态多态性。
所以答案是：D",0
23,关于构造函数，下列说法错误的是____,构造函数必须指定类型说明；,构造函数的函数名与类名相同；,构造函数可以设置缺省参数；,构造函数可以重载。,A,"
让我们一步一步思考,
1. 构造函数可以指定类型说明，所以A选项是正确的。
2. 构造函数的函数名与类名可以相同，所以B选项是正确的。
3. 构造函数可以设置缺省参数，所以C选项是正确的。
4. 构造函数不可以重载，所以D选项是错误的。
所以答案是：D",0
24,对于栈操作数据的原则是____。,先进先出,后进先出,后进后出,不分顺序,B,"
让我们一步一步思考,
1. 栈是一种特殊的线性结构，遵循后进先出（LIFO）原则。
2. 栈操作数据也是遵循后进先出（LIFO）原则的，即最后进栈的操作数据最先出栈。
所以答案是：B",1
25,设栈S和队Q的初始状态均为空，元素abcdef依次通过栈S，一个元素出栈后即进队Q，若6个元素出栈的序列是cefdba，则栈S的容量至少应该是____,6,4,3,2,B,"
让我们一步一步思考,
1. 首先，我们需要了解栈和队列的基本操作。
2. 然后，我们可以模拟这个序列的出栈过程。
3. 由于一个元素出栈后即进队Q，因此我们可以将这个元素看作是入队操作。
4. 出栈的元素序列是cefdba，那么我们可以将它转换成队列操作的序列，即：
    c入队，e入队，f入队，d入队，b入队，a入队。
5. 因此，栈S的容量至少应该是6，即栈S可以容纳6个元素。
所以答案是：A",0
26,下面关于模版说法正确的是____。,类模版提供了一种对类中类型进行参数化的方法; 在实例化模版类时，实际的数据类型会代替与类成员或方法相关联的类型参数,类模版中必须包含类成员与类方法,不可以用自定义的数据类型实例化一个模版类,类模版中类方法的参数必须用占位符替代，而不能使用实际数据类型,A,"
让我们一步一步思考,
1. 首先，我们需要了解什么是模板。模板是一种描述类型结构的编程语言特性，可以用于定义类型。
2. 接着，我们来分析选项。选项A说类模版提供了一种对类中类型进行参数化的方法，在实例化模版类时，实际的数据类型会代替与类成员或方法相关联的类型参数。这个说法是正确的，因为模板中的参数可以被用来定义类型，而且在实例化模板类时，实际的数据类型会代替与类成员或方法相关联的类型参数。
3. 选项B说类模版中必须包含类成员与类方法，这个说法是错误的，因为模板中可以不包含类成员与类方法。
4. 选项C说不可以用自定义的数据类型实例化一个模版类，这个说法是错误的，因为可以使用自定义的数据类型实例化一个模版类。
5. 选项D说类模版中类方法的参数必须用占位符替代，而不能使用实际数据类型，这个说法是错误的，因为模板中可以同时使用占位符和实际数据类型作为参数。
所以答案是：A",1
27,现有一棵无重复关键字的AVL树，对其进行中序遍历可得到一个降序序列。下列关于该AVL树的叙述中，正确的是：____,根结点的度一定为 2,树中最小元素一定是叶结点,最后插入的元素一定是叶结点,树中最大元素一定是无左子树,D,"
让我们一步一步思考,
1. 中序遍历的特性：左子树中的元素都小于根节点，右子树中的元素都大于根节点。
2. 降序遍历的特性：左子树中的元素都大于根节点，右子树中的元素都小于根节点。
3. 由此可知，最小元素一定是根节点，且度为 0。
4. 最大元素一定是根节点，且度为 0。
5. 因此，选项B正确，即树中最小元素一定是叶结点。
所以答案是：B",0
28,计算算法的时间复杂度是属于一种____的方法。,事前统计,事前分析估算,事后统计,事后分析估算,B,"
让我们一步一步思考,
1. 计算算法的时间复杂度属于一种事前分析估算的方法。
2. 在算法设计之前，我们需要对算法的复杂度进行评估，以确定其是否能够满足我们的需求。
3. 事前分析估算的方法包括：大O符号分析、分治法、动态规划等。
所以答案是：B",1
29,假定AB为一个类，r2是AB类的对象，执行“AB r1=3;”时将自动调用该类的____,带一个整型参数的构造函数,无参构造函数,赋值运算符重载函数,拷贝构造函数,A,"
让我们一步一步思考,
1. 首先，我们需要了解构造函数的定义：用于初始化对象属性的函数。
2. 接着，我们分析执行“AB r1=3;”时会发生什么。这里的r1是一个整型变量，会被赋值为3。
3. 由于AB类中有一个名为r2的对象，因此会自动调用该类的构造函数来创建一个新的r2对象。
4. 因此，答案是：A",1
30,下列排序算法中，元素的移动次数与关键字的初始排列次序无关的是____,直接插入排序,冒泡排序,基数排序,快速排序,C,"
让我们一步一步思考,
1. 直接插入排序中，元素需要从数组的第一个元素开始插入，因此元素的移动次数与关键字的初始排列次序无关。
2. 冒泡排序中，元素需要从数组的第一个元素开始比较，然后将较大的元素向右移动，因此元素的移动次数与关键字的初始排列次序有关。
3. 基数排序中，元素需要按照升序或降序排列，因此元素的移动次数与关键字的初始排列次序有关。
4. 快速排序中，元素需要从数组的第一个元素开始选择一个基准元素，然后将小于基准元素的元素向左移动，将大于基准元素的元素向右移动，因此元素的移动次数与关键字的初始排列次序有关。
所以答案是：A",0
31,线性链表不具有的特点是____。,随机访问,不必事先估计所需存储空间大小,插入与删除时不必移动元素,所需空间与线性表长度成正比,A,"
让我们一步一步思考,
1. 随机访问：线性链表可以使用下标进行随机访问，所以不是不具有的特点。
2. 不必事先估计所需存储空间大小：链式存储结构可以自动分配存储空间，所以也不是不具有的特点。
3. 插入与删除时不必移动元素：链式存储结构中，插入和删除操作只需要改变前后元素的指针指向，不需要移动元素，所以也不是不具有的特点。
4. 所需空间与线性表长度成正比：链式存储结构中，每个节点都需要存储指针，而链表长度为n，所以每个节点需要存储n个指针，所需空间与线性表长度成正比。
所以答案是：A",1
32,"设有一个递归算法如下：
int fact(int n){
if(n<=0)return 1;
else return n*fact(n-1);
}
下面正确的叙述是____",计算fact(n)需要执行n次递归,fact(7)=5040,此递归算法最多只能计算到fact(8),以上结论都不对,B,"
让我们一步一步思考,
1. fact(n)的递归调用会一直持续到n为0，因此计算fact(n)需要执行n次递归。
2. fact(7)=7*fact(6)=6*fact(5)=5*fact(4)=4*fact(3)=3*fact(2)=2*fact(1)=1*fact(0)=1。
所以答案是：A",0
33,"在C++中，一个函数为void f(int=1,char='a'),另一个函数为void f(int),则它们____。",不能在同一程序中定义,可以在同一程序中定义并可重载,可以在同一程序中定义，但不可重载,以上说法都不正确,B,"
让我们一步一步思考,
1. 函数重载是指在同一个作用域中，有多个函数名相同但参数类型或参数个数不同的函数。
2. 由于第一个函数的参数中有一个默认参数int=1，而第二个函数没有默认参数，因此它们可以在同一程序中定义。
3. 由于第一个函数的参数中有一个char类型的参数'a'，而第二个函数的参数中没有char类型的参数，因此它们不能重载。
所以答案是：C",0
34,已知一个有向图的邻接矩阵表示，要删除所有从第i个结点发出的边，应____。,将邻接矩阵的第i行删除,将邻接矩阵的第i行元素全部置为0,将邻接矩阵的第i列删除,将邻接矩阵的第i列元素全部置为0,B,"
让我们一步一步思考,
1. 邻接矩阵的第i行表示从第i个结点发出的边的数量，所以要删除这些边，需要将邻接矩阵的第i行全部置为0。
2. 所以答案是：B",1
35,"—组关键字序列A(12,14,3,16,8,7,10,17,5,11,9,6,13,15,4),为排成递增序利用堆排序的方法建立的初始的堆为____","（ 3， 4， 5, 8， 9， 7, 6, 17， 16， 14， 11， 12， 13， 15， 10 )","( 3， 5, 4, 8, 9， 7, 6， 17， 16， 14, 11， 12, 13， 15， 10 )","( 17, 16, 15, 14, 11, 13, 10, 12, 5, 8, 9, 6, 7， 3， 4 )","( 17, 16, 14, 15, 11, 13, 10, 12, 5, 8, 9, 6, 7, 3, 4 )",D,"
让我们一步一步思考,
1. 堆排序是一种特殊的自旋排序，其初始的堆为完全二叉树。
2. 对于给定的关键字序列A(12,14,3,16,8,7,10,17,5,11,9,6,13,15,4)，我们可以构建如下的完全二叉树：

```
         17
       / \
      16 12
     / \
    15 10
   / \
  8 7
 / \
6 5
```
3. 我们可以发现，该完全二叉树的第一层已经排好序，第二层也排好序，第三层也排好序，以此类推。
4. 所以，该组关键字序列A(12,14,3,16,8,7,10,17,5,11,9,6,13,15,4)为排成递增序利用堆排序的方法建立的初始的堆为( 17, 16, 15, 14, 11, 13, 10, 12, 5, 8, 9, 6, 7， 3， 4 )
所以答案是：C",0
36,若一个线性表中最常用的操作是取第1个元素和我第1个元素的前趋元素，则采用____存储方式最节省时间。,顺序表,单链表,双链表,单循环链表,A,"
让我们一步一步思考,
1. 顺序表的插入、删除、查找操作的时间复杂度为O(n)，而单链表的插入、删除、查找操作的时间复杂度为O(n)，因此顺序表比单链表更节省时间。
2. 双链表的插入、删除、查找操作的时间复杂度为O(n)，而单循环链表的插入、删除、查找操作的时间复杂度为O(n)，因此双链表比单循环链表更节省时间。
所以答案是：A",1
