id,question,A,B,C,D,answer,explanation
0,"在有n(n>1000)个元素的升序数组A中查找关键字x。查找算法的伪代码如下所示。
k=0;
while(k<n且A[k]<x)k=k+3；
if(k<n且A[k]==x)查找成功；
else if(k-1<n且A[k-1]==x)查找成功；
else if(k-2<n且A[k-2]==x)查找成功；
else 查找失败；
本算法与折半查找算法相比，有可能具有更少比较次数的情形是____",当 x 不在数组中,当 x 接近数组开头处,当 x 接近数组结尾处,当 x 位于数组中间位置,B,"1. 首先，我们需要了解折半查找算法的基本思想：在有序数组中查找关键字，每次将查找区间缩小一半，直到找到或者确定不存在为止。假设x所在位置为n，则查找次数为log_2n
2. 接着，我们分析给出的查找算法。该算法使用步长为3的跳跃方式，从数组开头开始查找，直到找到第一个大于等于x的元素或者查找到数组结尾。然后，再在跳跃过的3个元素中查找x，如果找到则查找成功，否则查找失败。查找次数为n/3+2
3. 显然一般情况下n/3+2>log_2n，只有 x 在开头处 n/3+2 好"
1,先序序列为a，b，c的不同二叉树的个数是____,3,5,4,6,B,1. 我们可以通过手动构建二叉树的方式来确定不同先序序列为a，b，c的二叉树个数。对于三个节点的二叉树，根据先序遍历的特点，a节点必须是根节点，那么b和c节点的分布共有5种情况：(1) b是a的左子树，c是a的右子树；(2) b是a的左子树，c是b的左子树；(3) b是a的左子树，c是b的右子树；(4) b是a的右子树，c是b的左子树；(5) b是a的右子树，c是b的右子树。
2,若森林F有15条边、25个结点，则F包含树的个数是____,8,9,10,11,C,"1. 首先，一个有n个结点的树有n-1条边，每棵树就会造成边的数量比结点数量少1
3. 接着，仅根无入分支。那么现在边的数量比结点数量少了25-15=10。
4. 所以，我们得到森林F包含10棵树。"
3,"#include<iostream.h>
#define SQR(x) x*x
void main()
{
int a=10,k=2,m=1;
a/=SQR(k+m);cout<<a;
}
执行上面的C++程序后，a的值是____。",10,2,9,0,B,"1. 首先，我们需要了解在这个程序中，SQR的 x 不是一个变量，编译器SQR(k+m)会被替换成k+m*k+m。
2. 其次，我们来分析程序的执行过程。SQR(k+m)=k+m*k+m的值为5。因此，a/=SQR(k+m)会被解释为a=a/SQR(k+m)，即a=a/5。由于a的初始值为10，因此a的值变为2。"
4,"在C++中，编写一个内联函数func,使用类型int的参数，求其平方并返回，返回值为int类型，下列定义____是正确的",int func(int x) {return (x*x);},inline int func(int x) {return (x*x);},int inline func(int x) {return (x*x);},int func(int x) {return (x*x);},B,1. 内联函数的inline需要放在前面。
